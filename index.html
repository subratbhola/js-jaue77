<div id="app"></div>
<ul>
  <li>Request cycle, atomic design, design systems</li>
  <strong
    >Atomic design: It devided into 5 parts thoes are atoms,molecules, organism,
    template and pages. atoms are like all html elements like input, select , h1
    etc.<br />
    Molecules are combination of atom . organism are combination of Molecules .
    template are combination of organism . pages are combination of template .
  </strong>
  <li>semantic html, dom</li>
  <strong
    >Semantic elements are article, aside, figcaption, header, footer, section
    etc <br />
  </strong>
  <li>forms and validatio</li>
  <li>media responsive image, audio, video</li>
  <li>
    <strong>
      browser side storage, workers and caching . local and session, cookies,
      indexdb, websql</strong
    >
    <ul>
      <li>Web storage- local and session: setItem, getItm, removeItem.</li>
      <li>
        caching: store a site assets in a memory location, which load the assets
        offline to give better performance
      </li>
      <li>
        Cookies: Cookies is a data , which stored in a file, when a user visit a
        site his name and details stored in a cookies. When you return to that
        site it remember your name and other input details <br />
        document.cookie = "username=John Smith; expires=Thu, 18 Dec 2013
        12:00:00 UTC; path=/";
      </li>
      <li>
        service worker: this used as a proxy between web browser and server. it
        aims to improve performance by downloading files online. there are few
        steps to implement
      </li>
      1. Create a -new service worker file.
      <br />
      2. resgister the service worker using navigator<br />
      3. then install using eventListner<br />
      4. then activate
      <br />
      5.
      <li>
        web worker: in javascript everything run on single thread. SO web workes
        used to run script in background to perform complication task without
        any interfierence to UI. Below are some web worker methods 1. using
        worker constructor we can set a web worker . worker = new Worker(); 2.
        use worker.onmessage() to fetch post data. 3. use postMessage() to post
        data.

        <!-- <p>Count numbers: <output id="result"></output></p>
        <button onclick="startWorker()">Start Worker</button>
        <button onclick="stopWorker()">Stop Worker</button>

        <p>
          <strong>Note:</strong> Internet Explorer 9 and earlier versions do not
          support Web Workers.
        </p> -->
      </li>
    </ul>
  </li>

  <li>SEO BASICS</li>
  <br />
  <br />
  <li>
    CSS OBJECT MODEL, RULES, selectors and property value, casecading,
    inheritance, specificity
  </li>
  <li>Responsive design mobile desktop media</li>
  <li>Layout [float, flex, grid], display possition</li>
  <li>Animations, translations basic, SVG</li>
  <li>processors / pre-processors, frameworks, css in js</li>
  <br />
  <br />

  <li>call(), bind(), apply(): these methods used to borrow function</li>
  <li>veriable, datatype, operator, if statement, loop</li>
  <li>foor each and for</li>
  <li>garbage collection</li>
  <li>events and event handling</li>
  <li>error handling</li> 
  <li>different factor bet es5 and es6</li>
  <li>dom manipulation</li>
  <li>Asynch programing:</li>
  <ul>
    <li>EVENT LOOP</li>
    <ul>
      <li>Event Loop is a endless process, where javascript engine waits for task and execute them and wait for more task. The priority give to Micro task queue. All the callBack funtions in javascript moved to callback queue</li>
      
      <li>MACRO: it has 2nd prioority on call back stack example: setTimeout, setInterval, setImmediate, requestAnimationFrame, I/O, UI rendering</li>
      <li>Micro task: it has first priority. Example: promies, mutation observer</li>
      <code>
      console.log('script start');  <br>
      setTimeout(function () {   <br>
        console.log('setTimeout')} <br>
        )
      Promise.resolve() . <br>
      then(function () { console.log('promise1'); }) ;  <br>

      console.log('script end'); <br>

      output console: script start, script end, promise1, setTimeout
      </code>
      <br>
      <code>
      console.log(1); <br>
      // The first line executes immediately, it outputs `1`. <br>
      // Macrotask and microtask queues are empty, as of now. <br>
      
      setTimeout(() => console.log(2));  <br>
      // `setTimeout` appends the callback to the macrotask queue.  <br>
      // - macrotask queue content:
      //   `console.log(2)`
      
      Promise.resolve().then(() => console.log(3));  <br>
      // The callback is appended to the microtask queue. <br>
      // - microtask queue content: <br>
      //   `console.log(3)` <br>
      
      Promise.resolve().then(() => setTimeout(() => console.log(4))); <br>
      // The callback with `setTimeout(...4)` is appended to microtasks  <br>
      // - microtask queue content: <br>
      //   `console.log(3); setTimeout(...4)` <br>
      
      Promise.resolve().then(() => console.log(5)); <br>
      // The callback is appended to the microtask queue <br>
      // - microtask queue content:
      //   `console.log(3); setTimeout(...4); console.log(5)` <br>
      
      setTimeout(() => console.log(6)); <br>
      // `setTimeout` appends the callback to macrotasks <br>
      // - macrotask queue content: <br>
      //   `console.log(2); console.log(6)` <br>
      
      console.log(7); <br>
      // Outputs 7 immediately.
      </code>
    </ul>
  </ul>
  <li>function</li>
  <ul>
    <li>Anonymous function: A function which dont have any name called Anonymous function</li>
    <li>clouser: A function along with its lexical environment forms a clouser. A clouser always remember its place holder or from where it belongs to</li>
    <li>callBack(): When we send a function as a argument insite another fuction its called a callback function</li>
    <li>setTimeout()</li>
    <li>first class function</li>
    <li>function statement, function expresion</li>
    <code>
     function abc() {console.log('function statement')} <br>
      let abc= function abc {console.log('function expression')}
    </code>
    <li>higher order function: Higher order functions are the functions which return a function exm: map(), filter(),reduce()</li>
    <li>Pure Function: with given the same input, it always return the same output, without side effect. examples are below</li>
    <code>
      //pure function <br>
      function (name) {return name}; //it takes input and sent output with no side effect (meanns we are not aritting anything which is not relevent to this function). <br>
      
      //impure function <br>
     var a = 10; <br>
     function printname() {<br>
       console.log(a) // it is taking value from global scope so this is a impure function <br>
    }
    </code>
  </ul>
  <li>
     FUnction Currying: When instead of sending all the parameter of a fucntion, we send first paramater then return a function then send 2 nd parameter and so on
  </li> 
  <li>object prototype: every veriable function , array and object are bydefault added to object.prototype</li>
   <li>prototypal inheritence:</li>
   <li>promises</li>
   <ul>
    <li>Chaining promises: When we return a promies on every fullfiling or resolve promies we called as promies chaining</li>
    <li>Promies.all: when there are array of promises which need to execute we can use promies.all, it will execute the promises in order . if it will any error in any promies it will terminate</li>
    <li>Promies.race : when there are more then one promies to be executed, we can use promies.race. But it will only return the first executed promies value. other promises will be ignored</li>
    <li>error handling</li>
    <li>asynch await: Asynch await makes promies easier to write. Asynch return a promies and await wait for the promies to fulfill</li>
  </ul>
</ul>

<p>Count numbers: <output id="result"></output></p>
<button onclick="startWorker()">Start Worker</button>
<button onclick="stopWorker()">Stop Worker</button>

<p>
  <strong>Note:</strong> Internet Explorer 9 and earlier versions do not support
  Web Workers.
</p>
